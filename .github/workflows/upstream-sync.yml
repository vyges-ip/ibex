name: Upstream Sync

on:
  schedule:
    # Run weekly on Monday at 00:00 UTC
    - cron: '0 0 * * 1'
  workflow_dispatch:  # Allow manual triggering
  push:
    # Trigger when upstream.yaml or workflow file is updated
    paths:
      - 'upstream.yaml'
      - '.github/workflows/upstream-sync.yml'

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Install yq and gh CLI
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          # gh CLI is pre-installed in GitHub Actions runners
      
      - name: Read upstream.yaml
        id: upstream
        run: |
          if [[ ! -f upstream.yaml ]]; then
            echo "Error: upstream.yaml not found"
            exit 1
          fi
          echo "repo=$(yq eval '.upstream.repo' upstream.yaml)" >> $GITHUB_OUTPUT
          echo "branch=$(yq eval '.upstream.branch' upstream.yaml)" >> $GITHUB_OUTPUT
          echo "commit=$(yq eval '.upstream.commit' upstream.yaml)" >> $GITHUB_OUTPUT
        continue-on-error: false
      
      - name: Check if initial sync needed
        id: initial_check
        run: |
          # Check if repository has any synced content
          if [[ ! -d rtl ]] && [[ ! -d vendor ]] && [[ ! -f LICENSE ]] && [[ ! -f README.md ]]; then
            echo "needs_initial_sync=true" >> $GITHUB_OUTPUT
            echo "Repository is empty, performing initial sync..."
          else
            echo "needs_initial_sync=false" >> $GITHUB_OUTPUT
            echo "Repository already has content, checking for updates..."
          fi
      
      - name: Clone upstream and check for updates
        id: check
        if: steps.initial_check.outputs.needs_initial_sync != 'true'
        run: |
          UPSTREAM_REPO="${{ steps.upstream.outputs.repo }}"
          UPSTREAM_BRANCH="${{ steps.upstream.outputs.branch }}"
          CURRENT_COMMIT="${{ steps.upstream.outputs.commit }}"
          
          # Clean up any existing clone
          rm -rf /tmp/upstream
          
          # Clone upstream (we'll reuse this clone for syncing if needed)
          git clone --quiet "$UPSTREAM_REPO" /tmp/upstream
          cd /tmp/upstream
          git checkout "$UPSTREAM_BRANCH" --quiet
          LATEST_COMMIT=$(git rev-parse HEAD)
          
          echo "current=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
          echo "latest=$LATEST_COMMIT" >> $GITHUB_OUTPUT
          
          if [[ "$CURRENT_COMMIT" == "$LATEST_COMMIT" ]]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Clone upstream for initial sync
        id: initial_clone
        if: steps.initial_check.outputs.needs_initial_sync == 'true'
        run: |
          UPSTREAM_REPO="${{ steps.upstream.outputs.repo }}"
          TARGET_COMMIT="${{ steps.upstream.outputs.commit }}"
          
          # Clean up any existing clone
          rm -rf /tmp/upstream
          
          # Clone upstream at specific commit for initial sync
          git clone --quiet "$UPSTREAM_REPO" /tmp/upstream
          cd /tmp/upstream
          git checkout "$TARGET_COMMIT" --quiet
          
          echo "‚úÖ Cloned upstream at commit $TARGET_COMMIT for initial sync"
      
      - name: Sync upstream files
        if: steps.check.outputs.has_changes == 'true' || steps.initial_check.outputs.needs_initial_sync == 'true'
        run: |
          # For initial sync, use the commit from upstream.yaml
          # For updates, checkout the latest commit in the already-cloned repo
          if [[ "${{ steps.initial_check.outputs.needs_initial_sync }}" == "true" ]]; then
            TARGET_COMMIT="${{ steps.upstream.outputs.commit }}"
            echo "Initial sync: using commit from upstream.yaml: $TARGET_COMMIT"
            # Repository already cloned and checked out in initial_clone step
          else
            TARGET_COMMIT="${{ steps.check.outputs.latest }}"
            echo "Update sync: checking out latest commit: $TARGET_COMMIT"
            # Repository already cloned in check step, just checkout the target commit
            cd /tmp/upstream
            git checkout "$TARGET_COMMIT" --quiet
          fi
          
          # Read import mappings from upstream.yaml
          cd "$GITHUB_WORKSPACE"
          
          # Read import mappings from upstream.yaml
          cd "$GITHUB_WORKSPACE"
          
          # Process RTL imports
          RTL_COUNT=$(yq eval '.import.rtl | length' upstream.yaml)
          for ((i=0; i<$RTL_COUNT; i++)); do
            UPSTREAM_PATH=$(yq eval ".import.rtl[$i].path" upstream.yaml)
            LOCAL_PATH=$(yq eval ".import.rtl[$i].map_to" upstream.yaml)
            echo "Syncing RTL: $UPSTREAM_PATH -> $LOCAL_PATH"
            mkdir -p "$LOCAL_PATH"
            cp -r "/tmp/upstream/$UPSTREAM_PATH"/* "$LOCAL_PATH/" 2>/dev/null || true
          done
          
          # Process patches imports
          if yq eval '.import.patches' upstream.yaml | grep -q "path"; then
            PATCHES_COUNT=$(yq eval '.import.patches | length' upstream.yaml)
            for ((i=0; i<$PATCHES_COUNT; i++)); do
              UPSTREAM_PATH=$(yq eval ".import.patches[$i].path" upstream.yaml)
              LOCAL_PATH=$(yq eval ".import.patches[$i].map_to" upstream.yaml)
              echo "Syncing patches: $UPSTREAM_PATH -> $LOCAL_PATH"
              mkdir -p "$(dirname "$LOCAL_PATH")"
              cp -r "/tmp/upstream/$UPSTREAM_PATH" "$LOCAL_PATH" 2>/dev/null || true
            done
          fi
          
          # Process license imports
          if yq eval '.import.license' upstream.yaml | grep -q "path"; then
            LICENSE_COUNT=$(yq eval '.import.license | length' upstream.yaml)
            for ((i=0; i<$LICENSE_COUNT; i++)); do
              UPSTREAM_PATH=$(yq eval ".import.license[$i].path" upstream.yaml)
              echo "Syncing license: $UPSTREAM_PATH"
              cp "/tmp/upstream/$UPSTREAM_PATH" . 2>/dev/null || true
            done
          fi
          
          # Process readme imports
          if yq eval '.import.readme' upstream.yaml | grep -q "path"; then
            README_COUNT=$(yq eval '.import.readme | length' upstream.yaml)
            for ((i=0; i<$README_COUNT; i++)); do
              UPSTREAM_PATH=$(yq eval ".import.readme[$i].path" upstream.yaml)
              echo "Syncing README: $UPSTREAM_PATH"
              cp "/tmp/upstream/$UPSTREAM_PATH" . 2>/dev/null || true
            done
          fi
          
          # Update upstream.yaml with new commit (only if this was an update, not initial sync)
          if [[ "${{ steps.initial_check.outputs.needs_initial_sync }}" != "true" ]]; then
            NEW_COMMIT="${{ steps.check.outputs.latest }}"
            yq eval ".upstream.commit = \"$NEW_COMMIT\"" -i upstream.yaml
            echo "‚úÖ Updated upstream.yaml commit to $NEW_COMMIT"
          fi
          
          echo "‚úÖ Files synced from upstream commit $TARGET_COMMIT"
      
      - name: Check if metadata file exists
        id: metadata_check
        run: |
          if [[ -f vyges-metadata.json ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ vyges-metadata.json already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è vyges-metadata.json does not exist, will generate"
          fi
      
      - name: Clone upstream for metadata generation (if needed)
        if: steps.metadata_check.outputs.exists == 'false' && steps.check.outputs.has_changes != 'true' && steps.initial_check.outputs.needs_initial_sync != 'true'
        run: |
          # If metadata doesn't exist and we haven't cloned upstream yet, clone it for version detection
          UPSTREAM_REPO=$(yq eval '.upstream.repo' upstream.yaml)
          UPSTREAM_BRANCH=$(yq eval '.upstream.branch' upstream.yaml)
          UPSTREAM_COMMIT=$(yq eval '.upstream.commit' upstream.yaml)
          
          if [[ ! -d /tmp/upstream ]] && [[ ! -d /tmp/upstream-check ]]; then
            echo "Cloning upstream for version detection..."
            rm -rf /tmp/upstream-metadata
            git clone --quiet "$UPSTREAM_REPO" /tmp/upstream-metadata
            cd /tmp/upstream-metadata
            git checkout "$UPSTREAM_COMMIT" --quiet
            cd "$GITHUB_WORKSPACE"
          fi
      
      - name: Generate or update vyges-metadata.json
        if: steps.check.outputs.has_changes == 'true' || steps.initial_check.outputs.needs_initial_sync == 'true' || steps.metadata_check.outputs.exists == 'false'
        run: |
          # Extract repository name from GitHub repository
          REPO_NAME="${{ github.repository }}"
          IP_NAME=$(echo "$REPO_NAME" | cut -d'/' -f2)
          
          # Extract upstream info from upstream.yaml
          UPSTREAM_REPO=$(yq eval '.upstream.repo' upstream.yaml)
          UPSTREAM_COMMIT=$(yq eval '.upstream.commit' upstream.yaml)
          LICENSE_SPDX=$(yq eval '.license.spdx // "Apache-2.0"' upstream.yaml)
          
          # Extract description from synced README if available
          DESCRIPTION="IP imported from $UPSTREAM_REPO"
          for readme in README.md README.rst README.txt README; do
            if [[ -f "$readme" ]]; then
              # Extract first meaningful line (skip title, empty lines, badges)
              desc_line=$(grep -v "^#" "$readme" | grep -v "^$" | grep -v "!\[" | head -1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              if [[ -n "$desc_line" ]] && [[ ${#desc_line} -gt 10 ]]; then
                # Truncate if too long
                if [[ ${#desc_line} -gt 200 ]]; then
                  DESCRIPTION="${desc_line:0:197}..."
                else
                  DESCRIPTION="$desc_line"
                fi
                break
              fi
            fi
          done
          
          # Try to extract version from git tags in upstream (if available)
          VERSION="1.0.0"
          # Check multiple possible locations for upstream clone
          for UPSTREAM_DIR in /tmp/upstream /tmp/upstream-check /tmp/upstream-metadata; do
            if [[ -d "$UPSTREAM_DIR" ]]; then
              cd "$UPSTREAM_DIR"
              # Try to find latest tag
              LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
              if [[ -n "$LATEST_TAG" ]]; then
                # Remove 'v' prefix if present
                VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
                echo "Found version from tag: $VERSION"
                break
              fi
              cd "$GITHUB_WORKSPACE"
            fi
          done
          cd "$GITHUB_WORKSPACE"
          
          # Check if vyges-metadata.json already exists
          if [[ -f vyges-metadata.json ]]; then
            echo "‚ö†Ô∏è vyges-metadata.json already exists, updating upstream info only"
            # Update upstream section if it exists, otherwise add it
            if jq -e '.upstream' vyges-metadata.json > /dev/null 2>&1; then
              jq --arg repo "$UPSTREAM_REPO" --arg commit "$UPSTREAM_COMMIT" \
                '.upstream.repo = $repo | .upstream.commit = $commit' \
                vyges-metadata.json > vyges-metadata.json.tmp && mv vyges-metadata.json.tmp vyges-metadata.json
            else
              jq --arg repo "$UPSTREAM_REPO" --arg commit "$UPSTREAM_COMMIT" \
                '. + {upstream: {repo: $repo, commit: $commit}}' \
                vyges-metadata.json > vyges-metadata.json.tmp && mv vyges-metadata.json.tmp vyges-metadata.json
            fi
            echo "‚úÖ Updated upstream info in existing vyges-metadata.json"
          else
            echo "üìù Generating new vyges-metadata.json skeleton"
            
            # Generate basic metadata skeleton
            jq -n \
              --arg name "vyges-ip/$IP_NAME" \
              --arg version "$VERSION" \
              --arg license "$LICENSE_SPDX" \
              --arg upstream_repo "$UPSTREAM_REPO" \
              --arg upstream_commit "$UPSTREAM_COMMIT" \
              --arg description "$DESCRIPTION" \
              '{
                name: $name,
                "x-version": $version,
                version: $version,
                description: $description,
                license: $license,
                template: "vyges-ip-template@1.0.0",
                target: ["asic", "fpga"],
                design_type: ["digital"],
                maturity: "draft",
                upstream: {
                  repo: $upstream_repo,
                  commit: $upstream_commit
                },
                interfaces: [],
                parameters: [],
                constraints: {
                  clock: [],
                  power: [],
                  area: {}
                },
                _note: "This is an auto-generated skeleton. Please fill in interfaces, parameters, and constraints based on RTL analysis."
              }' > vyges-metadata.json
            
            echo "‚úÖ Generated vyges-metadata.json skeleton"
            echo "   - Name: vyges-ip/$IP_NAME"
            echo "   - Version: $VERSION"
            echo "   - License: $LICENSE_SPDX"
            echo "   - Upstream: $UPSTREAM_REPO @ $UPSTREAM_COMMIT"
            echo ""
            echo "‚ö†Ô∏è  Note: Interfaces, parameters, and constraints need to be filled manually or via RTL analysis"
          fi
      
      - name: Commit and create PR
        if: steps.check.outputs.has_changes == 'true' || steps.initial_check.outputs.needs_initial_sync == 'true' || steps.metadata_check.outputs.exists == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if there are changes to commit
          if [[ -n "$(git status --porcelain)" ]]; then
            if [[ "${{ steps.initial_check.outputs.needs_initial_sync }}" == "true" ]]; then
              # Initial sync - commit directly to main/master
              BRANCH_NAME=$(git branch --show-current || echo "main")
              git add .
              COMMIT_MSG=$(printf "Initial sync from upstream commit %s\n\n- Synced RTL files, patches, license, and README\n- Generated vyges-metadata.json skeleton" "${{ steps.upstream.outputs.commit }}")
              git commit -m "$COMMIT_MSG"
              git push origin "$BRANCH_NAME"
              echo "‚úÖ Initial sync completed and pushed to $BRANCH_NAME"
            elif [[ "${{ steps.metadata_check.outputs.exists }}" == "false" ]]; then
              # Metadata generation only (no upstream changes)
              BRANCH_NAME=$(git branch --show-current || echo "main")
              git add .
              COMMIT_MSG=$(printf "Generate vyges-metadata.json\n\n- Auto-generated metadata skeleton\n- Upstream: %s @ %s" "$(yq eval '.upstream.repo' upstream.yaml)" "$(yq eval '.upstream.commit' upstream.yaml)")
              git commit -m "$COMMIT_MSG"
              git push origin "$BRANCH_NAME"
              echo "‚úÖ Generated and committed vyges-metadata.json"
            else
              # Update sync - create PR
              BRANCH_NAME="upstream-sync-${{ steps.check.outputs.latest }}"
              git checkout -b "$BRANCH_NAME"
              git add .
              git commit -m "Sync upstream from commit ${{ steps.check.outputs.latest }}"
              git push origin "$BRANCH_NAME"
              
              # Create PR
              gh pr create \
                --title "Upstream Sync: ${{ steps.check.outputs.latest }}" \
                --body "## Upstream Sync
            
            **Upstream commit**: \`${{ steps.check.outputs.latest }}\` (was \`${{ steps.check.outputs.current }}\`)
            
            ### Changes
            - Synced files according to upstream.yaml import section
            - Updated upstream.yaml commit hash
            - Updated vyges-metadata.json with latest upstream info
            
            ### Next Steps
            - Review changes
            - Merge when ready" \
                --base main || gh pr create \
                --title "Upstream Sync: ${{ steps.check.outputs.latest }}" \
                --body "## Upstream Sync
            
            **Upstream commit**: \`${{ steps.check.outputs.latest }}\` (was \`${{ steps.check.outputs.current }}\`)
            
            ### Changes
            - Synced files according to upstream.yaml import section
            - Updated upstream.yaml commit hash
            - Updated vyges-metadata.json with latest upstream info
            
            ### Next Steps
            - Review changes
            - Merge when ready" \
                --base master
            fi
          else
            echo "No changes to commit"
          fi
      
      - name: No changes detected
        if: steps.check.outputs.has_changes == 'false' && steps.initial_check.outputs.needs_initial_sync != 'true'
        run: |
          echo "‚úÖ Upstream is up to date (commit: ${{ steps.check.outputs.current }})"
